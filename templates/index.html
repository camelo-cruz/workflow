{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transcription App</title>
    <link rel="stylesheet" href="{% static 'style.css' %}">
    <meta name="csrf-token" content="{{ csrf_token }}">
</head>
<body>
<div class="container">
    <div class="sidebar"> 
        <h2 class="title">Automatic workflow LeibnizDream</h2>
        <form id="form-transcribe">
            <label for="action">Action</label>
            <select id="action" name="action" required>
                <option value="transcribe">Transcribe</option>
                <option value="translate">Translate</option>
                <option value="gloss">Gloss</option>
            </select>
        
            <label>Directory Path</label>
            <input type="text" id="base-dir" name="base_dir" placeholder="/path/to/dir" required>
        
            <label for="instruction">Instruction</label>
            <select id="instruction" name="instruction" required>
                <option value="corrected">corrected</option>
                <option value="automatic">automatic</option>
                <option value="sentences">sentences</option>
            </select>
        
            <label>Language</label>
            <input type="text" id="language" name="language" value="German" required>
        
            <!-- ðŸ’¥ Just buttons stacked -->
            <button id="btn-process" class="btn-primary" type="button">Start</button>
            <button id="btn-cancel" class="btn-secondary" type="button" style="display:none;">Cancel</button>
        
            <div id="status" class="status"></div>
        </form>
    </div>

    <div class="main">
        <img src="{% static 'zas_logo.jpg' %}" alt="Logo" class="logo">
        <p class="logo-text">LeibnizDream</p>
        <pre id="logs"></pre>
    </div>
</div>

<script>
    let currentJobId = null;
    let evt = null;
    
    async function startLogStream(jobId) {
    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("logs");
    const btnCancel = document.getElementById("btn-cancel");
    const btnProcess = document.getElementById("btn-process");

    // Use an AbortController so you can cancel the fetch if needed
    const controller = new AbortController();
    btnCancel.onclick = () => {
        controller.abort();
    };

    try {
        const response = await fetch(`/logs/${jobId}`, {
        signal: controller.signal,
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let finished = false;

        while (!finished) {
        const { value, done } = await reader.read();
        if (done) break;

        // Decode the chunk and append to the log element
        const chunk = decoder.decode(value, { stream: true });
        logEl.textContent += chunk;
        logEl.scrollTop = logEl.scrollHeight;

        // Check for terminal messages
        if (
            chunk.includes("[DONE ALL]") ||
            chunk.includes("[CANCELLED]") ||
            chunk.includes("[ERROR]")
        ) {
            finished = true;
        }
        }

        reader.releaseLock();
        localStorage.removeItem("job_id");
        btnCancel.style.display = "none";
        statusEl.textContent = "Finished.";
    } catch (err) {
        // Handles both network errors and abort()
        console.error("Fetch error:", err);
        localStorage.removeItem("job_id");
        btnCancel.style.display = "none";
        btnProcess.style.display = "block";
        logEl.textContent += "\n[ERROR] Error occurred. Job not finished\n";
        statusEl.textContent = "Error occurred. Job not finished";
    }
    }

    
    document.getElementById("btn-process").onclick = async () => {
        const base = document.getElementById("base-dir").value.trim();
        const language = document.getElementById("language").value.trim();
        const action = document.getElementById("action").value.trim();
        const instruction = document.getElementById("instruction").value.trim();
    
        const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    
        const payload = new FormData();
        payload.append("base_dir", base);
        payload.append("language", language);
        payload.append("action", action);
        payload.append("instruction", instruction);
    
        let res;
        try {
            res = await fetch("/process/", {
                method: "POST",
                body: payload,
                headers: {
                    "X-CSRFToken": csrfToken
                },
                credentials: "same-origin"
            });
        } catch (error) {
            console.error("Fetch error:", error);
            document.getElementById("status").textContent = "Failed to start job.";
            return;
        }
    
        if (!res.ok) {
            document.getElementById("status").textContent = "Failed to start job.";
            return;
        }
    
        let data;
        try {
            data = await res.json();
        } catch (error) {
            console.error("Error parsing JSON:", error);
            document.getElementById("status").textContent = "Invalid server response.";
            return;
        }
        
        const { job_id, error } = data;
        const statusEl = document.getElementById("status");
        const logEl = document.getElementById("logs");
        logEl.textContent = "";
    
        if (error) {
            statusEl.textContent = error;
            return;
        }
    
        if (!job_id) {
            statusEl.textContent = "Job ID missing.";
            return;
        }
    
        currentJobId = job_id;
        document.getElementById("btn-process").style.display = "none";
        localStorage.setItem("job_id", currentJobId); // âœ… Save to localStorage
        statusEl.textContent = "Job " + currentJobId + " started";
        document.getElementById("btn-cancel").style.display = "block";
    
        startLogStream(currentJobId);
    };
    
    document.getElementById("btn-cancel").onclick = async () => {
        if (!currentJobId) return;
    
        const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    
        try {
            await fetch(`/cancel/${currentJobId}`, {
                method: "POST",
                headers: {
                    "X-CSRFToken": csrfToken
                },
                credentials: "same-origin"
            });
    
            document.getElementById("status").textContent = "Cancelling...";
        } catch (error) {
            console.error("Error cancelling job:", error);
            document.getElementById("status").textContent = "Failed to cancel.";
        }
    };
    
    // âœ… When page loads, check if a job is still running
    window.addEventListener("load", () => {
        const savedJobId = localStorage.getItem("job_id");
        if (savedJobId) {
            currentJobId = savedJobId;
            document.getElementById("status").textContent = "Reconnected to job " + currentJobId;
            document.getElementById("btn-cancel").style.display = "block";
            startLogStream(currentJobId);
        }
    });
</script>
</body>
</html>